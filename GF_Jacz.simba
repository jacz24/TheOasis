{$UNDEF SCRIPT_ID}{$DEFINE SCRIPT_ID := ''}
{$UNDEF SCRIPT_REVISION}{$DEFINE SCRIPT_REVISION := '1'}
{$IFDEF WINDOWS}{$DEFINE SCRIPT_GUI}{$ENDIF}
{$I SRL-T/osr.simba}
{$I WaspLib/osr.simba}
type
  ETask = (
    TASK_TO_DO
  );

var
  CurrentTask: ETask := ETask.TASK_TO_DO;

type
  EGFState = (
    RUN_TEST,

    GRAB_COMMISION,
    SETUP_MOULD,
    WITHDRAW_BARS,
    FILL_CRUCIBLE,
    POUR_CRUCIBLE,
    GRAB_SWORD,


    HEAT_SWORD,
    COOL_SWORD,
    USE_POLISHING_WHEEL,
    USE_GRINDSTONE,
    USE_TRIP_HAMMER,
    SWORD_COMPLETE,

    HANDLE_LEVEL,
    CLOSE_BANK,
    WAIT_STATE,
    NO_ACTIVITY,
    END_SCRIPT
  );

  EProgressState = (WHEEL, STONE, HAMMER, NOTFOUND);
  ETemperatureState = (COLD, MEDIUM, HOT, USELESS);

  EMouldType = (FORTE, BLADES, TIPS, MOULDNONE);
  EBladeSize = (NARROW, BROAD, SizeNone);
  EBladeWeight = (HEAVY, LIGHT, WeightNone);
  EBladeType = (FLAT, SPIKED, TypeNone);

  ERSMouldSetupButton = (RESET_MOULD, SET_MOULD);

  TRefineTask = record
    TaskBounds: TBox;
    Refining: EProgressState;
    Active: Boolean;
    Idx: Int32;
  end;

  TRefineTaskBarArray = array of TRefineTask;

  TTempBar = record
    TemperatureBounds: TBox;
    SweetSpotBounds: TBox;
    Temperature: ETemperatureState;
    Active: Boolean;
    Idx: Int32;
  end;

  TTempBarArray = array of TTempBar;

  TRSRefineInterface = record
      Quality: TBox;
      AllBars: TBoxArray;
      IsSetup: Boolean;
      CurrentCommision: TStringArray;
      Temperature: record
        CursorPos: TPoint;
        CursorPosArray: TPointArray;
        CursorAttempt: Int32;
        Cold, Medium, Hot, Total: TBox;
        Useless, Combined: TBoxArray;
        TempBarArray: TTempBarArray;
      end;

      ProgressState: record
        Total: TBox;
        TaskBoxArray, AllProgressTasks: TBoxArray; // Outline of each progress task, and all tasks combined
        RefineTaskArray: TRefineTaskBarArray;
        CurrentRefineTask: TRefineTask;
      end;

    end;



  TRSGFMouldSetup = record(TRSTitledInterface)
    MouldTypeBoxes, Moulds, SetResetButtons: TBoxArray;
    //MouldSelect: TBoxArray;
    FINDER_UPTEXT: TStringArray;

  end;



  TProperties = record
    BladeSize: record
      SizeType: EBladeSize;
      Value: Int32;
    end;

    BladeWeight: record
      WeightType: EBladeWeight;
      Value: Int32;
    end;

    BladeType: record
      BladeType: EBladeType;
      Value: Int32;
    end;
  end;

  TRSGFMould = record
    //MouldType: EMouldType;
    MouldName: String;
    Properties: TProperties;
  end;

  TRSGFMouldArray = array of TRSGFMould;

  TGiantsFoundry = record(TBaseScript)
    State: EGFState;
    Commision: TStringArray;
    StuckTimer: TCountDown;
    MouldSetup: TRSGFMouldSetup;
    RefineInterface: TRSRefineInterface;
    ForteMoulds, BladeMoulds, TipMoulds: TRSGFMouldArray;
    BankChest, LavaPool, Waterfall, PolishingWheel,
    Grindstone, TripHammer, Crucible, MouldJig: TRSObjectV2;
    KovacNPC: TRSNPCV2;
    MouldSet, CrucibleFull, CruciblePoured: Boolean;
  end;


procedure TRSGFMouldSetup.Setup(); overload;
begin
  //inherited;
  Self.Name := 'Giants'' Foundry Mould Setup';

end;

procedure TRSGFMouldSetup.SetupAlignment(); overload;
var
  alignment: TRSInterfaceAlignment;
  i: Int32;
begin
  alignment.Left := InterfaceArea.Bounds.X1;
  alignment.Right := InterfaceArea.Bounds.X2;

  alignment.Top := InterfaceArea.Bounds.Y1 + 2;
  alignment.Bottom := InterfaceArea.Bounds.Y2;
  alignment.MaxWidth := 488;
  alignment.MaxHeight := 800;

  (*
  case RSClient.Mode of
    ERSClientMode.FIXED:
      alignment.Bottom := InterfaceArea.Bounds.Y2 - 1;
    ERSClientMode.RESIZABLE_CLASSIC, ERSClientMode.RESIZABLE_MODERN:
      alignment.Bottom := InterfaceArea.Bounds.Y2 - 2;
  end;
  *)

  Self.SetupAlignment(alignment);
  //Writeln(Self.Bounds);
  //Writeln(Self.Height);
  //Writeln(Self.Bounds);
  //Writeln(MainScreen.Bounds);
  //Writeln(InterfaceArea.Bounds);

  Self.ScrollArea.X1 := Self.Bounds.X1 + 139;
  Self.ScrollArea.Y1 := Self.Bounds.Y1 + 138;
  Self.ScrollArea.X2 := Self.ScrollArea.X1 + 308;
  Self.ScrollArea.Y2 := Self.ScrollArea.Y1 + 162;

  Self.MouldTypeBoxes := Grid(1, 3, 106, 28, [0, 13], [Self.Bounds.X1 + 16, Self.Bounds.Y1 + 130]);
  Self.Moulds := Grid(1, 11, 308, 41, [0, -1], [Self.ScrollArea.X1, Self.ScrollArea.Y1]);

  Self.SetResetButtons := Grid(1, 2, 112, 26,[0, 16], [Self.Bounds.X1 + 356, Self.Bounds.Y1 + 50]);
  Debug(Self.SetResetButtons);
  for i := 0 to High(Self.Moulds) do
    Self.Moulds[i] := Self.Moulds[i].Expand(-5); //shrink boxes because calculating scrolling is not linear.

  //Writeln(Self.Moulds.Len);
  //Self.ScrollArea.X1 := Self.Bounds.X1 + 140;
  //Self.ScrollArea.Y1 := Self.Bounds.Y1 + 139;
  //Self.ScrollArea.X2 := Self.ScrollArea.X1 + 322
  //Writeln(Self.GetScrollPosition());
  //Debug(Emotes.Area);
  //Debug(Self.Moulds);
  //Writeln(Self.GetScrollBar);
  //Writeln(Self.Moulds);
  //Debug(Self.ScrollArea);
  //Debug(Self.MouldTypeBoxes);
  //Debug(Self.Moulds);
end;

//function TRSGFMouldSetup.GetButtons(): TRSButtonArray:
//begin
  //Result := FindButtons([[]]);
//end;

function TRSGFMouldSetup._GetOffset(): Int32;
begin
  Result := -Round(Self.GetScrollPosition() * 2.7);
end;

function TRSGFMouldSetup.GetSlots(): TBoxArray;
var
  i: Int32;
begin
  Result := Self.Moulds.Offset([0, Self._GetOffset()]);
  //Writeln(Result.Len);
  //Writeln(Result);

  for i := High(Result) downto 0 do
  begin
    // Check if box intersects with scroll area
    // A box intersects if it's NOT completely outside
    if (Result[i].X2 >= Self.ScrollArea.X1) and
       (Result[i].X1 <= Self.ScrollArea.X2) and
       (Result[i].Y2 >= Self.ScrollArea.Y1) and
       (Result[i].Y1 <= Self.ScrollArea.Y2) then
    begin
      Result[i].LimitTo(Self.ScrollArea);
      Continue;
    end;

    // Box is completely outside scroll area, remove it
    //Delete(Result, i, 1);
  end;
end;

function TRSGFMouldSetup.GetActiveMouldType(): EMouldType;
var
  i: Int32;
begin
  Result := EMouldType.MOULDNONE;
  if SRL.CountColor(CTS0(3358536, 2), Self.MouldTypeBoxes[0]) > 0 then
    Result := EMouldType.FORTE;

  if SRL.CountColor(CTS0(3358536, 2), Self.MouldTypeBoxes[1]) > 0 then
    Result := EMouldType.BLADES;

  if SRL.CountColor(CTS0(3358536, 2), Self.MouldTypeBoxes[2]) > 0 then
    Result := EMouldType.TIPS;
end;

function TRSGFMouldSetup.IsOpen(): Boolean;
begin
  Result := Self.GetActiveMouldType <> EMouldType.MOULDNONE;
end;

function TRSGFMouldSetup.IsMouldReady(): Boolean;
begin
  Result := False;
  if SRL.CountColor(CTS0(3358536, 2), Self.SetResetButtons[1]) > 0 then
    Result := True;
end;

function TRSGFMouldSetup.SetMould(): Boolean;
begin
  Result := False;
  Mouse.Move(Self.SetResetButtons[1]);
  if MainScreen.IsUpText('ould') then
  begin
    Mouse.Click(MOUSE_LEFT);
    Result := True;
  end;
end;

function TRSGFMouldSetup.SelectMouldTypeButton(mouldbutton: EMouldType): Boolean;
begin
  if not Self.IsOpen() then
    Result := False;
  if mouldbutton = EMouldType.FORTE then
  begin
    if Self.GetActiveMouldType = EMouldType.FORTE then
      Exit(True);
    Mouse.Move(Self.MouldTypeBoxes[0]);
    if MainScreen.IsUpText('Forte') then
    begin
      Mouse.Click(MOUSE_LEFT);
      Result := True;
    end;
  end;
  if mouldbutton = EMouldType.BLADES then
  begin
    if Self.GetActiveMouldType = EMouldType.BLADES then
      Exit(True);
    Mouse.Move(Self.MouldTypeBoxes[1]);
    if MainScreen.IsUpText('Blades') then
    begin
      Mouse.Click(MOUSE_LEFT);
      Result := True;
    end;
  end;

  if mouldbutton = EMouldType.TIPS then
  begin
    if Self.GetActiveMouldType = EMouldType.TIPS then
      Exit(True);
    Mouse.Move(Self.MouldTypeBoxes[2]);
    if MainScreen.IsUpText('Tips') then
    begin
      Mouse.Click(MOUSE_LEFT);
      Result := True;
    end;
  end;

end;

function TRSGFMouldSetup.ContainsMould(mouldbox: TBox): Boolean;
begin
  Result := Self.ScrollArea.Contains(mouldbox);
end;

function TRSGFMouldSetup.FindMouldScroll(mouldbox: TBox; mouldtype: EMouldType): Boolean;
var
  scroll, nextScroll: Int32;
  down: Boolean;
begin
  if not Self.SelectMouldTypeButton(mouldtype) then
    Exit(False);

  if Self.ContainsMould(mouldbox) then
  begin
    Writeln('Found Mould Scrolling Not Needed!');

    Exit(True);
  end;

  if not Self.CanScroll() then
    Exit(False);

  scroll := Self.GetScrollPosition();

  down := (scroll > 0) or SRL.Dice(50);

  repeat
    if down then
      nextScroll := scroll - 1
    else
      nextScroll := scroll + 1;

    Self.SetScrollPosition(nextScroll);
    scroll := Self.GetScrollPosition();

    mouldbox := mouldbox.Offset([0, Self._GetOffset()]);
    if Self.ContainsMould(mouldbox) then
      Exit(True);

    if not Self.IsOpen() then
      Exit(False);
  until (scroll = 0) or (scroll = 100);

  down := not down;

  repeat
    if down then
      nextScroll := scroll - 1
    else
      nextScroll := scroll + 1;

    Self.SetScrollPosition(nextScroll);
    scroll := Self.GetScrollPosition();

    mouldbox := mouldbox.Offset([0, Self._GetOffset()]);
    Writeln(mouldbox);
    if Self.ContainsMould(mouldbox) then
      Exit(True);

    if not Self.IsOpen() then
      Exit(False);
  until (scroll = 0) or (scroll = 100);

  Exit(False);
end;

function TRSGFMouldSetup.SelectMould(mouldbox: TBox; mouldtype: EMouldType; mould: TRSGFMould): Boolean;
begin
  Result := False;
  if Self.FindMouldScroll(mouldbox, mouldtype) then
  begin
    mouldbox := mouldbox.Offset([0, Self._GetOffset()]);
    Mouse.Move(mouldbox);
    if MainScreen.IsUpText(mould.MouldName) then
      Mouse.Click(MOUSE_LEFT);
  end;
end;



procedure TGiantsFoundry.SetupMouldsData();
var
  tmp: TRSGFMould;
begin

  ////////// TIP MOULDS //////////

  tmp.MouldName := 'People Poker Point';
  tmp.Properties.BladeSize.SizeType := EBladeSize.NARROW;
  tmp.Properties.BladeSize.Value := 4;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.HEAVY;
  tmp.Properties.BladeWeight.Value := 4;
  tmp.Properties.BladeType.BladeType := EBladeType.FLAT;
  tmp.Properties.BladeType.Value := 4;
  Self.TipMoulds += tmp;

  tmp.MouldName := 'Chopper Tip';
  tmp.Properties.BladeSize.SizeType := EBladeSize.BROAD;
  tmp.Properties.BladeSize.Value := 4;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.LIGHT;
  tmp.Properties.BladeWeight.Value := 4;
  tmp.Properties.BladeType.BladeType := EBladeType.SPIKED;
  tmp.Properties.BladeType.Value := 4;
  Self.TipMoulds += tmp;

  tmp.MouldName := 'Medusa''s Head';
  tmp.Properties.BladeSize.SizeType := EBladeSize.BROAD;
  tmp.Properties.BladeSize.Value := 4;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.HEAVY;
  tmp.Properties.BladeWeight.Value := 4;
  tmp.Properties.BladeType.BladeType := EBladeType.SPIKED;
  tmp.Properties.BladeType.Value := 4;
  Self.TipMoulds += tmp;

  tmp.MouldName := 'Serpent''s Fang';
  tmp.Properties.BladeSize.SizeType := EBladeSize.NARROW;
  tmp.Properties.BladeSize.Value := 8;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.LIGHT;
  tmp.Properties.BladeWeight.Value := 6;
  tmp.Properties.BladeType.BladeType := EBladeType.SPIKED;
  tmp.Properties.BladeType.Value := 8;
  Self.TipMoulds += tmp;

  tmp.MouldName := 'Gladius Point';
  tmp.Properties.BladeSize.SizeType := EBladeSize.NARROW;
  tmp.Properties.BladeSize.Value := 8;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.HEAVY;
  tmp.Properties.BladeWeight.Value := 8;
  tmp.Properties.BladeType.BladeType := EBladeType.FLAT;
  tmp.Properties.BladeType.Value := 6;
  Self.TipMoulds += tmp;

  tmp.MouldName := 'Saw Tip';
  tmp.Properties.BladeSize.SizeType := EBladeSize.BROAD;
  tmp.Properties.BladeSize.Value := 6;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.HEAVY;
  tmp.Properties.BladeWeight.Value := 8;
  tmp.Properties.BladeType.BladeType := EBladeType.SPIKED;
  tmp.Properties.BladeType.Value := 8;
  Self.TipMoulds += tmp;


  tmp.MouldName := 'Corrupted Point';
  tmp.Properties.BladeSize.SizeType := EBladeSize.NARROW;
  tmp.Properties.BladeSize.Value := 8;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.LIGHT;
  tmp.Properties.BladeWeight.Value := 10;
  tmp.Properties.BladeType.BladeType := EBladeType.SPIKED;
  tmp.Properties.BladeType.Value := 8;
  Self.TipMoulds += tmp;

  tmp.MouldName := 'Defenders Tip';
  tmp.Properties.BladeSize.SizeType := EBladeSize.BROAD;
  tmp.Properties.BladeSize.Value := 10;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.HEAVY;
  tmp.Properties.BladeWeight.Value := 8;
  tmp.Properties.BladeType.BladeType := EBladeType.SPIKED;
  tmp.Properties.BladeType.Value := 8;
  Self.TipMoulds += tmp;

  tmp.MouldName := 'Serrated Tip';
  tmp.Properties.BladeSize.SizeType := EBladeSize.NARROW;
  tmp.Properties.BladeSize.Value := 4;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.LIGHT;
  tmp.Properties.BladeWeight.Value := 16;
  tmp.Properties.BladeType.BladeType := EBladeType.SPIKED;
  tmp.Properties.BladeType.Value := 4;
  Self.TipMoulds += tmp;

  tmp.MouldName := 'Needle Point';
  tmp.Properties.BladeSize.SizeType := EBladeSize.NARROW;
  tmp.Properties.BladeSize.Value := 18;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.LIGHT;
  tmp.Properties.BladeWeight.Value := 3;
  tmp.Properties.BladeType.BladeType := EBladeType.FLAT;
  tmp.Properties.BladeType.Value := 4;
  Self.TipMoulds += tmp;

  tmp.MouldName := 'The Point!';
  tmp.Properties.BladeSize.SizeType := EBladeSize.BROAD;
  tmp.Properties.BladeSize.Value := 2;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.LIGHT;
  tmp.Properties.BladeWeight.Value := 1;
  tmp.Properties.BladeType.BladeType := EBladeType.FLAT;
  tmp.Properties.BladeType.Value := 22;
  Self.TipMoulds += tmp;

  ////////// BLADE MOULDS //////////

  tmp.MouldName := 'Saw Blade';
  tmp.Properties.BladeSize.SizeType := EBladeSize.BROAD;
  tmp.Properties.BladeSize.Value := 4;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.LIGHT;
  tmp.Properties.BladeWeight.Value := 4;
  tmp.Properties.BladeType.BladeType := EBladeType.SPIKED;
  tmp.Properties.BladeType.Value := 4;
  Self.BladeMoulds += tmp;

  tmp.MouldName := 'Defenders Edge';
  tmp.Properties.BladeSize.SizeType := EBladeSize.BROAD;
  tmp.Properties.BladeSize.Value := 4;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.HEAVY;
  tmp.Properties.BladeWeight.Value := 4;
  tmp.Properties.BladeType.BladeType := EBladeType.SPIKED;
  tmp.Properties.BladeType.Value := 4;
  Self.BladeMoulds += tmp;

  tmp.MouldName := 'Fish Blade';
  tmp.Properties.BladeSize.SizeType := EBladeSize.NARROW;
  tmp.Properties.BladeSize.Value := 4;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.LIGHT;
  tmp.Properties.BladeWeight.Value := 4;
  tmp.Properties.BladeType.BladeType := EBladeType.FLAT;
  tmp.Properties.BladeType.Value := 4;
  Self.BladeMoulds += tmp;

  tmp.MouldName := 'Medusa Blade';
  tmp.Properties.BladeSize.SizeType := EBladeSize.BROAD;
  tmp.Properties.BladeSize.Value := 8;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.HEAVY;
  tmp.Properties.BladeWeight.Value := 8;
  tmp.Properties.BladeType.BladeType := EBladeType.FLAT;
  tmp.Properties.BladeType.Value := 6;
  Self.BladeMoulds += tmp;

  tmp.MouldName := 'Stiletto Blade';
  tmp.Properties.BladeSize.SizeType := EBladeSize.NARROW;
  tmp.Properties.BladeSize.Value := 8;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.LIGHT;
  tmp.Properties.BladeWeight.Value := 6;
  tmp.Properties.BladeType.BladeType := EBladeType.FLAT;
  tmp.Properties.BladeType.Value := 8;
  Self.BladeMoulds += tmp;

  tmp.MouldName := 'Gladius Edge';
  tmp.Properties.BladeSize.SizeType := EBladeSize.NARROW;
  tmp.Properties.BladeSize.Value := 6;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.HEAVY;
  tmp.Properties.BladeWeight.Value := 8;
  tmp.Properties.BladeType.BladeType := EBladeType.FLAT;
  tmp.Properties.BladeType.Value := 8;
  Self.BladeMoulds += tmp;

  tmp.MouldName := 'Flamberge Blade';
  tmp.Properties.BladeSize.SizeType := EBladeSize.NARROW;
  tmp.Properties.BladeSize.Value := 8;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.LIGHT;
  tmp.Properties.BladeWeight.Value := 8;
  tmp.Properties.BladeType.BladeType := EBladeType.SPIKED;
  tmp.Properties.BladeType.Value := 10;
  Self.BladeMoulds += tmp;

  tmp.MouldName := 'Serpent Blade';
  tmp.Properties.BladeSize.SizeType := EBladeSize.NARROW;
  tmp.Properties.BladeSize.Value := 10;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.LIGHT;
  tmp.Properties.BladeWeight.Value := 8;
  tmp.Properties.BladeType.BladeType := EBladeType.FLAT;
  tmp.Properties.BladeType.Value := 8;
  Self.BladeMoulds += tmp;

  tmp.MouldName := 'Claymore Blade';
  tmp.Properties.BladeSize.SizeType := EBladeSize.BROAD;
  tmp.Properties.BladeSize.Value := 16;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.HEAVY;
  tmp.Properties.BladeWeight.Value := 4;
  tmp.Properties.BladeType.BladeType := EBladeType.FLAT;
  tmp.Properties.BladeType.Value := 4;
  Self.BladeMoulds += tmp;

  tmp.MouldName := 'Fleur de Blade';
  tmp.Properties.BladeSize.SizeType := EBladeSize.BROAD;
  tmp.Properties.BladeSize.Value := 4;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.HEAVY;
  tmp.Properties.BladeWeight.Value := 18;
  tmp.Properties.BladeType.BladeType := EBladeType.SPIKED;
  tmp.Properties.BladeType.Value := 1;
  Self.BladeMoulds += tmp;

  tmp.MouldName := 'Choppa!';
  tmp.Properties.BladeSize.SizeType := EBladeSize.BROAD;
  tmp.Properties.BladeSize.Value := 1;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.LIGHT;
  tmp.Properties.BladeWeight.Value := 22;
  tmp.Properties.BladeType.BladeType := EBladeType.FLAT;
  tmp.Properties.BladeType.Value := 2;
  Self.BladeMoulds += tmp;

  ////////// BLADE MOULDS //////////

  tmp.MouldName := 'Chopper Forte';
  tmp.Properties.BladeSize.SizeType := EBladeSize.BROAD;
  tmp.Properties.BladeSize.Value := 4;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.LIGHT;
  tmp.Properties.BladeWeight.Value := 4;
  tmp.Properties.BladeType.BladeType := EBladeType.FLAT;
  tmp.Properties.BladeType.Value := 4;
  Self.ForteMoulds += tmp;

  tmp.MouldName := 'Gladius Ricasso';
  tmp.Properties.BladeSize.SizeType := EBladeSize.BROAD;
  tmp.Properties.BladeSize.Value := 4;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.HEAVY;
  tmp.Properties.BladeWeight.Value := 4;
  tmp.Properties.BladeType.BladeType := EBladeType.FLAT;
  tmp.Properties.BladeType.Value := 4;
  Self.ForteMoulds += tmp;

  tmp.MouldName := 'Disarming Forte';
  tmp.Properties.BladeSize.SizeType := EBladeSize.NARROW;
  tmp.Properties.BladeSize.Value := 4;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.LIGHT;
  tmp.Properties.BladeWeight.Value := 4;
  tmp.Properties.BladeType.BladeType := EBladeType.SPIKED;
  tmp.Properties.BladeType.Value := 4;
  Self.ForteMoulds += tmp;

  tmp.MouldName := 'Medusa Ricasso';
  tmp.Properties.BladeSize.SizeType := EBladeSize.BROAD;
  tmp.Properties.BladeSize.Value := 8;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.HEAVY;
  tmp.Properties.BladeWeight.Value := 6;
  tmp.Properties.BladeType.BladeType := EBladeType.FLAT;
  tmp.Properties.BladeType.Value := 8;
  Self.ForteMoulds += tmp;

  tmp.MouldName := 'Serpent Ricasso';
  tmp.Properties.BladeSize.SizeType := EBladeSize.NARROW;
  tmp.Properties.BladeSize.Value := 6;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.LIGHT;
  tmp.Properties.BladeWeight.Value := 8;
  tmp.Properties.BladeType.BladeType := EBladeType.FLAT;
  tmp.Properties.BladeType.Value := 8;
  Self.ForteMoulds += tmp;

  tmp.MouldName := 'Serrated Forte';
  tmp.Properties.BladeSize.SizeType := EBladeSize.NARROW;
  tmp.Properties.BladeSize.Value := 8;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.HEAVY;
  tmp.Properties.BladeWeight.Value := 8;
  tmp.Properties.BladeType.BladeType := EBladeType.SPIKED;
  tmp.Properties.BladeType.Value := 6;
  Self.ForteMoulds += tmp;

  tmp.MouldName := 'Stiletto Forte';
  tmp.Properties.BladeSize.SizeType := EBladeSize.NARROW;
  tmp.Properties.BladeSize.Value := 8;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.LIGHT;
  tmp.Properties.BladeWeight.Value := 10;
  tmp.Properties.BladeType.BladeType := EBladeType.FLAT;
  tmp.Properties.BladeType.Value := 8;
  Self.ForteMoulds += tmp;

  tmp.MouldName := 'Defender Base';
  tmp.Properties.BladeSize.SizeType := EBladeSize.BROAD;
  tmp.Properties.BladeSize.Value := 8;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.HEAVY;
  tmp.Properties.BladeWeight.Value := 10;
  tmp.Properties.BladeType.BladeType := EBladeType.FLAT;
  tmp.Properties.BladeType.Value := 8;
  Self.ForteMoulds += tmp;

  tmp.MouldName := 'Juggernaut Forte';
  tmp.Properties.BladeSize.SizeType := EBladeSize.BROAD;
  tmp.Properties.BladeSize.Value := 4;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.HEAVY;
  tmp.Properties.BladeWeight.Value := 4;
  tmp.Properties.BladeType.BladeType := EBladeType.SPIKED;
  tmp.Properties.BladeType.Value := 16;
  Self.ForteMoulds += tmp;

  tmp.MouldName := 'Chopper Forte +1';
  tmp.Properties.BladeSize.SizeType := EBladeSize.BROAD;
  tmp.Properties.BladeSize.Value := 3;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.LIGHT;
  tmp.Properties.BladeWeight.Value := 4;
  tmp.Properties.BladeType.BladeType := EBladeType.FLAT;
  tmp.Properties.BladeType.Value := 18;
  Self.ForteMoulds += tmp;

  tmp.MouldName := 'Spiker!';
  tmp.Properties.BladeSize.SizeType := EBladeSize.NARROW;
  tmp.Properties.BladeSize.Value := 1;
  tmp.Properties.BladeWeight.WeightType := EBladeWeight.HEAVY;
  tmp.Properties.BladeWeight.Value := 2;
  tmp.Properties.BladeType.BladeType := EBladeType.SPIKED;
  tmp.Properties.BladeType.Value := 22;
  Self.ForteMoulds += tmp;

end;

procedure TGiantsFoundry.SetupInterface();
var
  tmp: TBox;
  i: Int32;
begin
  // Get Entire Quality Box
  Self.RefineInterface.Quality.X1 := MainScreen.Bounds.X1 + 48;
  Self.RefineInterface.Quality.Y1 := MainScreen.Bounds.Y1 + 38;

  Self.RefineInterface.Quality.X2 := Self.RefineInterface.Quality.X1 + 441;
  Self.RefineInterface.Quality.Y2 := Self.RefineInterface.Quality.Y1 + 14;

  // Get Entire Temperature Box
  Self.RefineInterface.Temperature.Total := Self.RefineInterface.Quality.Offset([0, 21]);

  // Get Entire Progress Bar and adjust to fit the bars size
  Self.RefineInterface.ProgressState.Total := Self.RefineInterface.Temperature.Total.Offset([0, 21]);
  Self.RefineInterface.ProgressState.Total.Y2 := Self.RefineInterface.ProgressState.Total.Y2 + 5;

  // Find First Useless(Grey) Part Of Temperature Bar
  tmp.X1 := Self.RefineInterface.Temperature.Total.X1;
  tmp.Y1 := Self.RefineInterface.Temperature.Total.Y1;
  tmp.X2 := Self.RefineInterface.Temperature.Total.X1 + 24;
  tmp.Y2 := Self.RefineInterface.Temperature.Total.Y2;
  Self.RefineInterface.Temperature.Useless += tmp;


  // Find Second Useless(Grey) Part Of Temperature Bar
  tmp.X1 := Self.RefineInterface.Temperature.Useless[0].X2 + 97;
  tmp.X2 := tmp.X1 + 50;
  Self.RefineInterface.Temperature.Useless += tmp;

  // Find Third Useless(Grey) Part Of Temperature Bar
  tmp.X1 := Self.RefineInterface.Temperature.Useless[1].X2 + 97;
  tmp.X2 := tmp.X1 + 50;
  Self.RefineInterface.Temperature.Useless += tmp;

  // Find Fourth Useless(Grey) Part Of Temperature Bar
  tmp.X1 := Self.RefineInterface.Temperature.Useless[2].X2 + 97;
  tmp.X2 := tmp.X1 + 26;
  Self.RefineInterface.Temperature.Useless += tmp;

  // Find Cold(Green) Part of Temperature Bar
  Self.RefineInterface.Temperature.Cold.X1 := Self.RefineInterface.Temperature.Useless[0].X2 + 1;
  Self.RefineInterface.Temperature.Cold.Y1 := Self.RefineInterface.Temperature.Total.Y1;
  Self.RefineInterface.Temperature.Cold.X2 := Self.RefineInterface.Temperature.Cold.X1 + 95;
  Self.RefineInterface.Temperature.Cold.Y2 := Self.RefineInterface.Temperature.Total.Y2;

  // Find Medium(Orange) Part of Temperature Bar
  Self.RefineInterface.Temperature.Medium.X1 := Self.RefineInterface.Temperature.Useless[1].X2 + 1;
  Self.RefineInterface.Temperature.Medium.Y1 := Self.RefineInterface.Temperature.Total.Y1;
  Self.RefineInterface.Temperature.Medium.X2 := Self.RefineInterface.Temperature.Medium.X1 + 95;
  Self.RefineInterface.Temperature.Medium.Y2 := Self.RefineInterface.Temperature.Total.Y2;

  // Find Hot(Red) Part of Temperature Bar
  Self.RefineInterface.Temperature.Hot.X1 := Self.RefineInterface.Temperature.Useless[2].X2 + 1;
  Self.RefineInterface.Temperature.Hot.Y1 := Self.RefineInterface.Temperature.Total.Y1;
  Self.RefineInterface.Temperature.Hot.X2 := Self.RefineInterface.Temperature.Hot.X1 + 95;
  Self.RefineInterface.Temperature.Hot.Y2 := Self.RefineInterface.Temperature.Total.Y2;

  Self.RefineInterface.Temperature.Combined += [Self.RefineInterface.Temperature.Useless[0],
  Self.RefineInterface.Temperature.Cold, Self.RefineInterface.Temperature.Useless[1],
  Self.RefineInterface.Temperature.Medium, Self.RefineInterface.Temperature.Useless[2],
  Self.RefineInterface.Temperature.Hot, Self.RefineInterface.Temperature.Useless[3]];

  // Sets the length of the TempBarArray to the number of temp bars in the array
  SetLength(Self.RefineInterface.Temperature.TempBarArray, Self.RefineInterface.Temperature.Combined.Len);


  // Populate the TempBoundsArray with correct info
  for i := 0 to High(Self.RefineInterface.Temperature.Combined) do
  begin
    Self.RefineInterface.Temperature.TempBarArray[i].TemperatureBounds := Self.RefineInterface.Temperature.Combined[i];
    Self.RefineInterface.Temperature.TempBarArray[i].Idx := i;
  end;

  Self.RefineInterface.Temperature.TempBarArray[0].Temperature := ETemperatureState.USELESS;
  Self.RefineInterface.Temperature.TempBarArray[1].Temperature := ETemperatureState.COLD;
  Self.RefineInterface.Temperature.TempBarArray[2].Temperature := ETemperatureState.USELESS;
  Self.RefineInterface.Temperature.TempBarArray[3].Temperature := ETemperatureState.MEDIUM;
  Self.RefineInterface.Temperature.TempBarArray[4].Temperature := ETemperatureState.USELESS;
  Self.RefineInterface.Temperature.TempBarArray[5].Temperature := ETemperatureState.HOT;
  Self.RefineInterface.Temperature.TempBarArray[6].Temperature := ETemperatureState.USELESS;

  // Hard Coded For Adamant and Mithril... To Add a case switch for difficulty
  tmp.X1 := Self.RefineInterface.ProgressState.Total.X1;
  tmp.Y1 := Self.RefineInterface.ProgressState.Total.Y1;
  tmp.X2 := Self.RefineInterface.ProgressState.Total.X1 + 88;
  tmp.Y2 := Self.RefineInterface.ProgressState.Total.Y2;
  Self.RefineInterface.ProgressState.TaskBoxArray += tmp;

  tmp.X1 := Self.RefineInterface.ProgressState.TaskBoxArray[0].X2 + 1;
  tmp.Y1 := Self.RefineInterface.ProgressState.Total.Y1;
  tmp.X2 := Self.RefineInterface.ProgressState.TaskBoxArray[0].X2 + 88;
  tmp.Y2 := Self.RefineInterface.ProgressState.Total.Y2;
  Self.RefineInterface.ProgressState.TaskBoxArray += tmp;

  tmp.X1 := Self.RefineInterface.ProgressState.TaskBoxArray[1].X2 + 1;
  tmp.Y1 := Self.RefineInterface.ProgressState.Total.Y1;
  tmp.X2 := Self.RefineInterface.ProgressState.TaskBoxArray[1].X2 + 88;
  tmp.Y2 := Self.RefineInterface.ProgressState.Total.Y2;
  Self.RefineInterface.ProgressState.TaskBoxArray += tmp;

  tmp.X1 := Self.RefineInterface.ProgressState.TaskBoxArray[2].X2 + 1;
  tmp.Y1 := Self.RefineInterface.ProgressState.Total.Y1;
  tmp.X2 := Self.RefineInterface.ProgressState.TaskBoxArray[2].X2 + 88;
  tmp.Y2 := Self.RefineInterface.ProgressState.Total.Y2;
  Self.RefineInterface.ProgressState.TaskBoxArray += tmp;

  tmp.X1 := Self.RefineInterface.ProgressState.TaskBoxArray[3].X2 + 1;
  tmp.Y1 := Self.RefineInterface.ProgressState.Total.Y1;
  tmp.X2 := Self.RefineInterface.ProgressState.TaskBoxArray[3].X2 + 88;
  tmp.Y2 := Self.RefineInterface.ProgressState.Total.Y2;
  Self.RefineInterface.ProgressState.TaskBoxArray += tmp;

  // Sets the length of the RefineTaskArray to the number of taskboxs in the array
  SetLength(Self.RefineInterface.ProgressState.RefineTaskArray, Self.RefineInterface.ProgressState.TaskBoxArray.Len);

  // Add Bars To A Large Array Of All The Bars For Debugging
  Self.RefineInterface.AllBars += Self.RefineInterface.Quality;
  //Self.RefineInterface.AllBars += Self.RefineInterface.Temperature.Total;
  //Self.RefineInterface.AllBars += Self.RefineInterface.ProgressState.Total;

  Self.RefineInterface.AllBars += Self.RefineInterface.Temperature.Cold;
  Self.RefineInterface.AllBars += Self.RefineInterface.Temperature.Medium;
  Self.RefineInterface.AllBars += Self.RefineInterface.Temperature.Hot;
  Self.RefineInterface.AllBars += Self.RefineInterface.Temperature.Useless;

  //Self.RefineInterface.AllBars += Self.RefineInterface.ProgressState.TaskBoxArray;

  Self.SetupSweetSpots();

  Debug(Self.RefineInterface.AllBars);
end;

procedure TGiantsFoundry.Init(maxActions: UInt32; maxTime: UInt64); override;
begin
  inherited;

  Map.SetupChunk(Chunk([51, 180, 53, 178], 0));
  Objects.Setup(Map.Objects(), @Map.Walker);

  Self.BankChest := Objects.get('Bank chest');
  Self.BankChest.Finder.Colors += CTS2(2313603, 23, 0.19, 1.91);

  Self.Crucible := TRSObjectV2.Setup(3, [[9396, 4472]]);
  Self.Crucible.SetupUpText('rucible');
  Self.Crucible.Finder.Colors += CTS2(6637890, 15, 0.14, 0.87);
  Self.Crucible.Walker := @Map.Walker;

  Self.MouldJig := TRSObjectV2.Setup(2, [[9386, 4472]]);
  Self.MouldJig.SetupUpText('ould');
  Self.MouldJig.Finder.Colors += CTS2(7438191, 17, 1.49, 0.24);
  Self.MouldJig.Walker := @Map.Walker;

  Self.LavaPool := Objects.Get('Lava pool');
  Self.Waterfall := Objects.Get('Waterfall');

  Self.PolishingWheel := Objects.Get('Polishing wheel');
  Self.PolishingWheel.Finder.Colors += CTS2(8549247, 17, 1.33, 0.30);

  Self.Grindstone := Objects.Get('Grindstone');
  Self.TripHammer := Objects.Get('Trip Hammer');

  Self.KovacNPC := TRSNPCV2.Setup(20, 6, [[9380,4482], [9384,4482], [9380,4486], [9384,4486]]);
  Self.KovacNPC.SetupUpText('Kovac');
  Self.KovacNPC.Finder.Colors += CTS2(4812425, 21, 0.03, 0.38);
  Self.KovacNPC.Finder.Colors += CTS2(2830439, 18, 0.09, 0.61);
  //Self.KovacNPC.Finder.Colors += CTS2(5261638, 13, 0.40, 0.39);
  Self.KovacNPC.Walker := @Map.Walker;

  Self.SetupInterface();
  Self.SetupMouldsData();

  Self.MouldSet := False;
  Self.CrucibleFull := False;
  Self.CruciblePoured := False;
end;



function TGiantsFoundry.InterfaceIsOpen(): Boolean;
begin
  Result := SRL.CountColor(CTS0(4621632, 0), Self.RefineInterface.Temperature.Total) > 0
end;

function TGiantsFoundry.GetActiveRefineTask(): TRefineTask;
var
  i: Int32;
begin
  for i := 0 to High(Self.RefineInterface.ProgressState.RefineTaskArray) do
  begin
    if SRL.CountColor(CTS0(16777215, 0), Self.RefineInterface.ProgressState.RefineTaskArray[i].TaskBounds) > 0 then
    begin
      Exit(Self.RefineInterface.ProgressState.RefineTaskArray[i]);
    end else
      Self.RefineInterface.ProgressState.RefineTaskArray[i].Active := False;
  end;

  Result := [];
end;

// Sets the Active flag to true in the object
procedure TGiantsFoundry.SetActiveRefineTask();
begin
  Self.RefineInterface.ProgressState.RefineTaskArray[Self.GetActiveRefineTask.Idx].Active := True;
end;



function TGiantsFoundry.SetupProgressStates(): Boolean;
var
  i: Int32;
begin
  if not Self.InterfaceIsOpen() then
    Exit(False);
  Self.RefineInterface.ProgressState.AllProgressTasks := [];
  //Self.RefineInterface.ProgressState.RefineTaskArray := [];

  for i := 0 to High(Self.RefineInterface.ProgressState.TaskBoxArray) do
  begin
    Self.RefineInterface.ProgressState.RefineTaskArray[i].Refining := EProgressState.NOTFOUND;
    if SRL.CountColor(CTS0(1927902, 0), Self.RefineInterface.ProgressState.TaskBoxArray[i]) > 0 then // For Orange
    begin
      Self.RefineInterface.ProgressState.RefineTaskArray[i].TaskBounds := Self.RefineInterface.ProgressState.TaskBoxArray[i];
      Self.RefineInterface.ProgressState.RefineTaskArray[i].Refining := EProgressState.STONE;
      Self.RefineInterface.ProgressState.AllProgressTasks += Self.RefineInterface.ProgressState.RefineTaskArray[i].TaskBounds;
    end;
    if SRL.CountColor(CTS0(4482857, 0), Self.RefineInterface.ProgressState.TaskBoxArray[i]) > 0 then // For Green
    begin
      Self.RefineInterface.ProgressState.RefineTaskArray[i].TaskBounds := Self.RefineInterface.ProgressState.TaskBoxArray[i];
      Self.RefineInterface.ProgressState.RefineTaskArray[i].Refining := EProgressState.WHEEL;
      Self.RefineInterface.ProgressState.AllProgressTasks += Self.RefineInterface.ProgressState.RefineTaskArray[i].TaskBounds;
    end;
    if SRL.CountColor(CTS0(3810928, 0), Self.RefineInterface.ProgressState.TaskBoxArray[i]) > 0 then // For Red
    begin
      Self.RefineInterface.ProgressState.RefineTaskArray[i].TaskBounds := Self.RefineInterface.ProgressState.TaskBoxArray[i];
      Self.RefineInterface.ProgressState.RefineTaskArray[i].Refining := EProgressState.HAMMER;
      Self.RefineInterface.ProgressState.AllProgressTasks += Self.RefineInterface.ProgressState.RefineTaskArray[i].TaskBounds;
    end;


    Self.RefineInterface.ProgressState.RefineTaskArray[i].Idx := i; // Sets the index of the array to the object
  end;
  //Debug(Self.RefineInterface.ProgressState.AllProgressTasks);
  Exit(True);
end;

function TGiantsFoundry.FindCursor(bar: TBox): TPoint;
var
  tpa: TPointArray;
begin
  if SRL.FindColors(tpa, CTS0(13421772, 0), bar) = 0 then
    Exit;
  Result := tpa.First();
end;

function TGiantsFoundry.IsCursorInBox(bar: TBox): Boolean;
begin
  Result := bar.Contains(Self.FindCursor(bar));
end;

//function TGiantsFoundry.CoolOrHeat()
function TGiantsFoundry.IsCursorBehindBox(wholebar, bar: TBox): Boolean;
begin
  Result := Self.FindCursor(wholebar).X < bar.X1;
end;

function TGiantsFoundry.IsCursorInFrontBox(wholebar, bar: TBox): Boolean;
begin
  Result := Self.FindCursor(wholebar).X > bar.X2;
end;

function TGiantsFoundry.IsSwordComplete(): Boolean;
begin
  Result := SRL.CountColor(CTS0(1119339, 0), Self.RefineInterface.ProgressState.Total) > 0;
end;


function TGiantsFoundry.AtLavaPool(): Boolean;
begin
  Result := Self.LavaPool.Coordinates.AnyInRange(Map.Position(), 8);
end;

function TGiantsFoundry.AtWaterfall(): Boolean;
begin
  Result := Self.Waterfall.Coordinates.AnyInRange(Map.Position(), 8);
end;

function TGiantsFoundry.IsCoolingSword(): Boolean;
var
  temprange: Double;
  test: Boolean;
begin

  Result := Self.Waterfall.Coordinates.AnyInRange(Map.Position(), 8);

  (*
  temprange := Self.FindCursor(Self.RefineInterface.Temperature.Total).DistanceTo(Point(Self.RefineInterface.Temperature.Total.X1,
  Self.RefineInterface.Temperature.Total.Y1));

  test := WaitUntil(temprange > Self.FindCursor(Self.RefineInterface.Temperature.Total).DistanceTo(Point(Self.RefineInterface.Temperature.Total.X1,
  Self.RefineInterface.Temperature.Total.Y1)), 100, 1200);

  Writeln(temprange);
  Writeln(test);

  Result := test
  *)
end;

function TGiantsFoundry.IsHeatingSword(): Boolean;
var
  temprange: Double;
  test: Boolean;
begin

  Result := Self.LavaPool.Coordinates.AnyInRange(Map.Position(), 8);
  (*

  temprange := Self.FindCursor(Self.RefineInterface.Temperature.Total).DistanceTo(Point(Self.RefineInterface.Temperature.Total.X1,
  Self.RefineInterface.Temperature.Total.Y1));



  test := WaitUntil(temprange < Self.FindCursor(Self.RefineInterface.Temperature.Total).DistanceTo(Point(Self.RefineInterface.Temperature.Total.X1,
  Self.RefineInterface.Temperature.Total.Y1)), 100, 1200);

  Writeln(temprange);
  Writeln(test);
  Result := test
  *)
end;

procedure TGiantsFoundry.UseLavaPool();
begin
  if Self.LavaPool.WalkClick(True, 2) then
  begin
    Minimap.WaitMoving();
  end;
  //Wait(583, 792);
  //
end;

procedure TGiantsFoundry.UseWaterFall();
begin
  if Self.Waterfall.WalkClick(True, 2) then
  begin
    Minimap.WaitMoving();
  end;
end;

procedure TGiantsFoundry.UseGrindstone();
begin
  if Self.Grindstone.WalkClick(True, 2) then
  begin
    Minimap.WaitMoving();
  end;
end;

procedure TGiantsFoundry.UsePolishingWheel();
begin
  if Self.PolishingWheel.WalkClick(True, 2) then
  begin
    Minimap.WaitMoving();
  end;
end;

procedure TGiantsFoundry.UseTripHammer();
begin
  if Self.TripHammer.WalkClick(True, 2) then
  begin
    Minimap.WaitMoving();
  end;
end;

procedure TGiantsFoundry.ResetToMiddleTile(attempt: Int32); // Checks to see if we are stuck
begin
  if Self.RefineInterface.Temperature.CursorAttempt >= attempt then
  begin

    Writeln(Self.RefineInterface.Temperature.CursorPosArray.First);
    Writeln(Self.RefineInterface.Temperature.CursorPos);

    if Self.RefineInterface.Temperature.CursorPosArray.First.InRange(Self.RefineInterface.Temperature.CursorPos, 10) then
    begin
      Writeln("Sitting Idle! Resetting to middle");
      //Writeln(Self.RefineInterface.Temperature.CursorPosArray.First.InRange(Self.RefineInterface.Temperature.CursorPos, 15));
    end;

    Writeln("Resetting Attempts");
    Self.RefineInterface.Temperature.CursorAttempt := 0;
    Self.RefineInterface.Temperature.CursorPosArray := []
  end;
  Self.RefineInterface.Temperature.CursorPos := Self.FindCursor(Self.RefineInterface.Temperature.Total);
  Self.RefineInterface.Temperature.CursorPosArray.Append(Self.FindCursor(Self.RefineInterface.Temperature.Total));
  Self.RefineInterface.Temperature.CursorAttempt += 1;


end;



procedure TGiantsFoundry.SetupSweetSpots();
begin
  Self.RefineInterface.Temperature.TempBarArray[5].SweetSpotBounds :=
    Box(Self.RefineInterface.Temperature.Hot.X1 + 55, Self.RefineInterface.Temperature.Hot.Y1,
    Self.RefineInterface.Temperature.Hot.X2, Self.RefineInterface.Temperature.Hot.Y2);

  Self.RefineInterface.Temperature.TempBarArray[3].SweetSpotBounds :=
    Box(Self.RefineInterface.Temperature.Medium.X1 + 5, Self.RefineInterface.Temperature.Medium.Y1,
    Self.RefineInterface.Temperature.Medium.X2 - 55, Self.RefineInterface.Temperature.Medium.Y2);

  Self.RefineInterface.Temperature.TempBarArray[1].SweetSpotBounds :=
    Box(Self.RefineInterface.Temperature.Cold.X1 + 55, Self.RefineInterface.Temperature.Cold.Y1,
    Self.RefineInterface.Temperature.Cold.X2, Self.RefineInterface.Temperature.Cold.Y2);

end;

procedure TGiantsFoundry.TurnInSword();
begin
  Writeln("Sword Complete, Hand-In To Kovac!");
  if Self.KovacNPC.WalkSelectOption(['Hand']) then
  begin
    Minimap.WaitMoving();
  end;

  WaitUntil(Chat.GetChatTitle = 'Kovac', 250, 5000);
  Chat.ClickContinue();
end;

function TGiantsFoundry.GetCommision(): TStringArray;
var
  request: TRSChatboxOption;
  tmp: TStringArray;
begin
  for request in Chat.GetOptions([CHAT_COLOR_RED]) do
    tmp += request.Text;
  Result := tmp;
end;

procedure TGiantsFoundry.GetCommisionFromKovac();
begin
  //Writeln("Sword Complete, Hand-In To Kovac!");
  if Self.KovacNPC.WalkSelectOption(['Com']) then
  begin
    Minimap.WaitMoving();
  end;
end;

function TGiantsFoundry.StringArrayToBladeSize(commision: TStringArray): EBladeSize;
var
  i: Int32;
  upper: String;
begin
  Result := EBladeSize.SizeNone;

  for i := 0 to High(commision) do
  begin
    upper := UpperCase(commision[i]);
    if upper.Contains('BROAD') then
    begin
      Result := EBladeSize.BROAD;
    end;
    if upper.Contains('NARROW') then
    begin
      Result := EBladeSize.NARROW;
    end;
  end;

end;

function TGiantsFoundry.StringArrayToBladeType(commision: TStringArray): EBladeType;
var
  i: Int32;
  upper: String;
begin
  Result := EBladeType.TypeNone;

  for i := 0 to High(commision) do
  begin

    upper := UpperCase(commision[i]);
    if upper.Contains('FLAT') then
    begin
      Result := EBladeType.FLAT;
    end;
    if upper.Contains('SPIKED') then
    begin
      Result := EBladeType.SPIKED;
    end;
  end;

end;

function TGiantsFoundry.StringArrayToBladeWeight(commision: TStringArray): EBladeWeight;
var
  i: Int32;
  upper: String;
begin
  Result := EBladeWeight.WeightNone;

  for i := 0 to High(commision) do
  begin
    upper := UpperCase(commision[i]);
    if upper.Contains('LIGHT') then
    begin
      Result := EBladeWeight.LIGHT;
    end;
    if upper.Contains('HEAVY') then
    begin
      Result := EBladeWeight.HEAVY;
    end;
  end;

end;

function TGiantsFoundry.GetOptimalMould(moulds: TRSGFMouldArray; commision: TStringArray): TRSGFMould;
var
  i, currenttotal, maxtotal: Int32;
  size: EBladeSize;
  weight: EBladeWeight;
  blade: EBladeType;
  optimalmould: TRSGFMould;
begin
  size := Self.StringArrayToBladeSize(commision);
  weight := Self.StringArrayToBladeWeight(commision);
  blade := Self.StringArrayToBladeType(commision);

  Writeln(size);
  Writeln(weight);
  Writeln(blade);
  for i := 0 to High(moulds) do
  begin
    currenttotal := 0; // Reset currenttoal before adding everything up
    if moulds[i].Properties.BladeSize.SizeType = size then
      currenttotal += moulds[i].Properties.BladeSize.Value;

    if moulds[i].Properties.BladeWeight.WeightType = weight then
      currenttotal += moulds[i].Properties.BladeWeight.Value;

    if moulds[i].Properties.BladeType.BladeType = blade then
      currenttotal += moulds[i].Properties.BladeType.Value;
    // Check if this is the highest so far
    if currenttotal > maxtotal then
    begin
      maxtotal := currenttotal;
      optimalmould := moulds[i];
    end;

  end;
  Writeln(optimalmould);
  Result := optimalmould;
end;

function TGiantsFoundry.FindMouldIndex(moulds: TRSGFMouldArray; mould: TRSGFMould): Int32;
var
  i: Int32;
begin
  Result := -1;
  for i := 0 to high(moulds) do
  begin
    //Writeln(moulds[i]);
    //Writeln(mould);
    if moulds[i].MouldName = mould.MouldName then
      Exit(i);
  end;
end;

procedure TGiantsFoundry.SelectBestForteMould();
var
  bestfortemould: TRSGFMould;
  mouldIdx, slotIdx: Int32;
begin
  bestfortemould := Self.GetOptimalMould(Self.ForteMoulds, Self.Commision);
  mouldIdx := Self.FindMouldIndex(Self.ForteMoulds, bestfortemould);

  if mouldIdx = -1 then
  begin
    Writeln('ERROR: Best mould not found in ForteMoulds array!');
    Exit;
  end;

  slotIdx := Length(Self.ForteMoulds) - mouldIdx - 1;

  if (slotIdx < 0) or (slotIdx >= Length(Self.MouldSetup.GetSlots)) then
  begin
    Writeln('ERROR: Calculated slot index out of bounds: ', slotIdx);
    Exit;
  end;

  Self.MouldSetup.SelectMould(Self.MouldSetup.GetSlots[slotIdx], EMouldType.FORTE, bestfortemould);

  //Writeln(slotIdx);
  //Writeln(Self.MouldSetup.GetSlots[slotIdx]);


  (*
  bestfortemould := Self.GetOptimalMould(Self.ForteMoulds, Self.Commision);

  Writeln(Length(Self.ForteMoulds) - Self.FindMouldIndex(Self.ForteMoulds, bestfortemould)- 1);
  Writeln(Self.MouldSetup.GetSlots[Length(Self.ForteMoulds) - Self.FindMouldIndex(Self.ForteMoulds, bestfortemould)]);
  Self.MouldSetup.SelectMould(Self.MouldSetup.GetSlots[Length(Self.ForteMoulds) - Self.FindMouldIndex(Self.ForteMoulds, bestfortemould)- 1], EMouldType.FORTE, bestfortemould);
  *)
end;

procedure TGiantsFoundry.SelectBestBladesMould();
var
  bestbladesmould: TRSGFMould;
  mouldIdx, slotIdx: Int32;
begin
  bestbladesmould := Self.GetOptimalMould(Self.BladeMoulds, Self.Commision);
  mouldIdx := Self.FindMouldIndex(Self.BladeMoulds, bestbladesmould);

  if mouldIdx = -1 then
  begin
    Writeln('ERROR: Best mould not found in BladeMoulds array!');
    Exit;
  end;

  slotIdx := Length(Self.BladeMoulds) - mouldIdx - 1;

  if (slotIdx < 0) or (slotIdx >= Length(Self.MouldSetup.GetSlots)) then
  begin
    Writeln('ERROR: Calculated slot index out of bounds: ', slotIdx);
    Exit;
  end;

  Self.MouldSetup.SelectMould(Self.MouldSetup.GetSlots[slotIdx], EMouldType.BLADES, bestbladesmould);
end;

procedure TGiantsFoundry.SelectBestTipsMould();
var
  besttipsmould: TRSGFMould;
  mouldIdx, slotIdx: Int32;
begin
  besttipsmould := Self.GetOptimalMould(Self.TipMoulds, Self.Commision);
  mouldIdx := Self.FindMouldIndex(Self.TipMoulds, besttipsmould);

  if mouldIdx = -1 then
  begin
    Writeln('ERROR: Best mould not found in TipMoulds array!');
    Exit;
  end;

  slotIdx := Length(Self.TipMoulds) - mouldIdx - 1;

  if (slotIdx < 0) or (slotIdx >= Length(Self.MouldSetup.GetSlots)) then
  begin
    Writeln('ERROR: Calculated slot index out of bounds: ', slotIdx);
    Exit;
  end;

  Self.MouldSetup.SelectMould(Self.MouldSetup.GetSlots[slotIdx], EMouldType.TIPS, besttipsmould);
end;

procedure TGiantsFoundry.GrabCommision();
begin
  Self.GetCommisionFromKovac();
  WaitUntil(Chat.GetChatTitle = 'Kovac', 250, 5000);
  Self.Commision := Self.GetCommision();
  //Self.Commision := Self.Commision.;
  Writeln(Self.Commision);
end;

procedure TGiantsFOundry.SetupMould();
begin
  if Self.MouldJig.WalkClick() then
    Writeln('Setting Mould!');

  WaitUntil(Self.MouldSetup.IsOpen(), 250, 5000);

  if Self.MouldSetup.SelectMouldTypeButton(EMouldType.FORTE) then
    SelectBestForteMould();

  Wait(338, 690);

  if Self.MouldSetup.SelectMouldTypeButton(EMouldType.BLADES) then
    SelectBestBladesMould();

  Wait(338, 690);

  if Self.MouldSetup.SelectMouldTypeButton(EMouldType.TIPS) then
    SelectBestTipsMould();

  if WaitUntil(Self.MouldSetup.IsMouldReady(), 250, 5000) then
    Self.MouldSetup.SetMould();

  if WaitUntil(not Self.MouldSetup.IsOpen(), 250, 5000) then
    Self.MouldSet := True;
end;

procedure TGiantsFoundry.WithdrawBars();
begin
  Self.BankChest.WalkClick();
  WaitUntil(Bank.IsOpen(), 250, 5000);

  Bank.WithdrawItem(['Adamantite bar', 10, False], True);

  Bank.WithdrawItem(['Mithril bar', 10, False], True);
  WaitUntil(Inventory.CountItem('Mithril bar') = 10, 300, 5000);
  Bank.WithdrawItem(['Mithril bar', 10, False], True);

  //if WaitUntil(Inventory.IsFull(), 300, 5000) then
  //  Bank.Close();
end;

procedure TGiantsFoundry.FillCrucible();
begin
  if not Make.IsOpen() then
    Self.Crucible.WalkClick();

  if WaitUntil(Make.IsOpen(), 300, 5000) then
  begin
    if Inventory.ContainsItem('Mithril bar') then
      Make.Select(3, Make.QUANTITY_ALL, True);

    WaitUntil(not Inventory.ContainsItem('Mithril bar'), 300, 5000);
    WaitUntil(Chat.HasContinue, 300, 5000);
    WaitUntil(Chat.ClickContinue, 300, 5000);
  end;

  if not Make.IsOpen() then
    Self.Crucible.WalkClick();

  if WaitUntil(Make.IsOpen(), 300, 5000) then
  begin
    if Inventory.ContainsItem('Adamantite bar') then
      Make.Select(4, Make.QUANTITY_ALL, True);

    WaitUntil(not Inventory.ContainsItem('Adamantite bar'), 300, 5000);
    WaitUntil(Chat.HasContinue, 300, 5000);
    WaitUntil(Chat.ClickContinue, 300, 5000);
  end;

  Self.CrucibleFull := True;
end;

procedure TGiantsFoundry.PourCrucible();
begin
  if Self.Crucible.Hover() then
  begin
    if WaitUntil(MainScreen.IsUpText('full'), 300, 5000) then
      Mouse.Click(MOUSE_LEFT);
  end;

  if WaitUntil(MainScreen.IsUpText('empty'), 300, 5000) then
    Self.CruciblePoured := True
end;

procedure TGiantsFoundry.GrabSword();
begin
  if Self.MouldJig.Hover() then
  begin
    if WaitUntil(MainScreen.IsUpText('metal'), 300, 5000) then
      Mouse.Click(MOUSE_LEFT);
  end;

  WaitUntil(Self.InterfaceIsOpen(), 300, 5000);
end;

procedure TGiantsFoundry.GetNewSword();
begin
  Self.TurnInSword();
  Chat.ClickOption('Yes.');


  Self.MouldSet := False;
  Self.CrucibleFull := False;
  Self.CruciblePoured := False;
  Self.Commision := [];
end;
function TGiantsFoundry.GetInterfaceOpenState(): EGFState;
begin
  XPBar.EarnedXP();
  Self.RefineInterface.IsSetup := Self.SetupProgressStates();
  Self.RefineInterface.ProgressState.CurrentRefineTask := Self.GetActiveRefineTask(); // Get Current Active TRefineTask
  Self.RefineInterface.Temperature.CursorPos := Self.FindCursor(Self.RefineInterface.Temperature.Total);

  if Self.IsSwordComplete then
    Exit(EGFState.SWORD_COMPLETE);
  if (Self.RefineInterface.ProgressState.CurrentRefineTask.Refining = EProgressState.WHEEL) and not Self.IsSwordComplete then
  begin
    if Self.IsCursorInFrontBox(Self.RefineInterface.Temperature.Total, Self.RefineInterface.Temperature.Cold) and not Self.AtWaterfall and not Self.IsCursorInBox(Self.RefineInterface.Temperature.TempBarArray[1].SweetSpotBounds) then
    begin
      Writeln("Need to cool down");
      Exit(EGFState.COOL_SWORD);
    end;

    if Self.IsCursorBehindBox(Self.RefineInterface.Temperature.Total, Self.RefineInterface.Temperature.Cold) and not Self.AtLavaPool and not Self.IsCursorInBox(Self.RefineInterface.Temperature.TempBarArray[1].SweetSpotBounds) then
    begin
      Writeln("Need to Warm up");
      Exit(EGFState.HEAT_SWORD);
    end;

    if not Self.PolishingWheel.Coordinates.AnyInRange(Map.Position(), 8) and Self.IsCursorInBox(Self.RefineInterface.Temperature.TempBarArray[1].SweetSpotBounds) then
    begin
      Writeln("Time To Use Wheel!");
      Exit(EGFState.USE_POLISHING_WHEEL);
    end;
  end;

  if (Self.RefineInterface.ProgressState.CurrentRefineTask.Refining = EProgressState.STONE) and not Self.IsSwordComplete then
  begin
    if Self.IsCursorInFrontBox(Self.RefineInterface.Temperature.Total, Self.RefineInterface.Temperature.Medium) and not Self.AtWaterfall and not Self.IsCursorInBox(Self.RefineInterface.Temperature.TempBarArray[3].SweetSpotBounds) then
    begin
      Writeln("Need to cool down for grindstone");
      Exit(EGFState.COOL_SWORD);
    end;

    if Self.IsCursorBehindBox(Self.RefineInterface.Temperature.Total, Self.RefineInterface.Temperature.Medium) and not Self.AtLavaPool and not Self.IsCursorInBox(Self.RefineInterface.Temperature.TempBarArray[3].SweetSpotBounds) then
    begin
      Writeln("Need to Warm up for grindstone");
      Exit(EGFState.HEAT_SWORD);
    end;

    if not Self.Grindstone.Coordinates.AnyInRange(Map.Position(), 8) and Self.IsCursorInBox(Self.RefineInterface.Temperature.TempBarArray[3].SweetSpotBounds) then
    begin
      Writeln("Time To Use Grindstone!");
      Exit(EGFState.USE_GRINDSTONE);
    end;
  end;

  if (Self.RefineInterface.ProgressState.CurrentRefineTask.Refining = EProgressState.HAMMER) and not Self.IsSwordComplete then
  begin
    if Self.IsCursorInFrontBox(Self.RefineInterface.Temperature.Total, Self.RefineInterface.Temperature.Hot) and not Self.AtWaterfall and not Self.IsCursorInBox(Self.RefineInterface.Temperature.TempBarArray[5].SweetSpotBounds) then
    begin
      Writeln("Need to cool down for hammer");
      Exit(EGFState.COOL_SWORD);
    end;

    if Self.IsCursorBehindBox(Self.RefineInterface.Temperature.Total, Self.RefineInterface.Temperature.Hot) and not Self.AtLavaPool and not Self.IsCursorInBox(Self.RefineInterface.Temperature.TempBarArray[5].SweetSpotBounds) then
    begin
      Writeln("Need to Warm up for hammer");
      Exit(EGFState.HEAT_SWORD);
    end;

    if not Self.TripHammer.Coordinates.AnyInRange(Map.Position(), 16) and Self.IsCursorInBox(Self.RefineInterface.Temperature.TempBarArray[5].SweetSpotBounds) then
    begin
      Writeln("Time To Use Hammer!");
      Exit(EGFState.USE_TRIP_HAMMER);
    end;
  end;
end;

function TGiantsFoundry.GetState(): EGFState;
var
  timeOut: UInt64;
  makesword: EGFState;
begin
  if Self.ShouldStop() then
    Exit(EGFState.END_SCRIPT);

  if Chat.LeveledUp() then Exit(EGFState.HANDLE_LEVEL);

  timeOut := GetSystemTime() + 15000;
  //Self.RunTest();
  //Exit(EGFState.END_SCRIPT);
  //WaitUntil(IsAnimating or Self.IsCursorInBox(Self.RefineInterface.Temperature.TempBarArray[5].SweetSpotBounds, 25, 5000);
  if Self.InterfaceIsOpen() then
  begin
    makesword := Self.GetInterfaceOpenState;
    Exit(makesword);
  end;

  if not Self.InterfaceIsOpen() then
    if Self.Commision = [] then
      Exit(EGFState.GRAB_COMMISION);

    if (Self.Commision <> []) and not Self.MouldSet then
      Exit(EGFState.SETUP_MOULD);

    if (Self.Commision <> []) and Self.MouldSet and not Self.CrucibleFull and not Inventory.ContainsAny(['Adamantite bar', 'Mithril bar']) and not Bank.IsOpen() then
     Exit(EGFState.WITHDRAW_BARS);

    if (Self.Commision <> []) and Self.MouldSet and Inventory.IsFull and Bank.IsOpen() then
      Exit(EGFState.CLOSE_BANK);

    if (Self.Commision <> []) and Self.MouldSet and Inventory.ContainsAny(['Adamantite bar', 'Mithril bar']) and not Bank.IsOpen() then
      Exit(EGFState.FILL_CRUCIBLE);

    if (Self.Commision <> []) and Self.MouldSet and Self.CrucibleFull and not Self.CruciblePoured and not Inventory.ContainsAny(['Adamantite bar', 'Mithril bar']) and not Bank.IsOpen() then
      Exit(EGFState.POUR_CRUCIBLE);

    if (Self.Commision <> []) and Self.MouldSet and Self.CrucibleFull and Self.CruciblePoured and not Inventory.ContainsAny(['Adamantite bar', 'Mithril bar']) and not Bank.IsOpen() then
      Exit(EGFState.GRAB_SWORD);

  if WL.Activity.IsFinished() then
    Exit(EGFState.NO_ACTIVITY);

  if GetSystemTime() > timeOut then
    Writeln('We are stuck! Resetting to middle');

  Exit(EGFState.WAIT_STATE);
end;

procedure TGiantsFoundry.Run(maxActions: UInt32; maxTime: UInt64);
begin
  Self.Init(maxActions, maxTime);
  Self.MouldSetup.SetupAlignment(); // Setup Mould Interface
  repeat
    Self.State := Self.GetState();
    Self.SetAction(ToStr(Self.State));

    case Self.State of
      //EGFState.RUN_TEST: Self.RunTest();
      EGFState.COOL_SWORD: Self.UseWaterFall();
      EGFState.HEAT_SWORD: Self.UseLavaPool();
      EGFState.USE_GRINDSTONE: Self.UseGrindstone();
      EGFState.USE_POLISHING_WHEEL: Self.UsePolishingWheel();
      EGFState.USE_TRIP_HAMMER: Self.UseTripHammer();
      EGFState.SWORD_COMPLETE: Self.GetNewSword();

      EGFState.GRAB_COMMISION: Self.GrabCommision();
      EGFState.SETUP_MOULD: Self.SetupMould();
      EGFState.WITHDRAW_BARS: Self.WithdrawBars();
      EGFState.CLOSE_BANK: Bank.Close();
      EGFState.FILL_CRUCIBLE: Self.FillCrucible();
      EGFState.POUR_CRUCIBLE: Self.PourCrucible();
      EGFState.GRAB_SWORD: Self.GrabSword();


      EGFState.HANDLE_LEVEL: Chat.HandleLevelUp();
      EGFState.WAIT_STATE: Wait(500, 800);//Self.GetActiveProgressState();//
      EGFState.NO_ACTIVITY, EGFState.END_SCRIPT: Break;
    end;

    //Self.DoAntiban();
  until False;
end;

var
  GiantsFoundry: TGiantsFoundry;

procedure TAntiban.Setup(); override;
begin
  Self.Skills := [ERSSkill.SMITHING, ERSSkill.TOTAL];
  Self.MinZoom := 15;
  Self.MaxZoom := 40;

  inherited;
end;

{$IFDEF SCRIPT_GUI}
type
  TGiantsFoundryConfig = record(TScriptForm)
    Selector: TLabeledCombobox;
  end;

procedure TGiantsFoundryConfig.StartScript(sender: TObject); override;
begin
  CurrentTask := ETask(Self.Selector.Combobox.getItemIndex);
  inherited;
end;

procedure TGiantsFoundryConfig.Run(); override;
var
  tab: TTabSheet;
begin
  Self.Setup('Giants Foundry By Jacz');
  Self.Start.setOnClick(@Self.StartScript);

  Self.AddTab('Script Settings');
  tab := Self.Tabs[High(Self.Tabs)];

  Self.CreateAccountManager(tab);

  with Self.Selector do
  begin
    Create(tab);
    SetCaption('Item type:');
    SetLeft(TControl.AdjustToDPI(40));
    SetTop(TControl.AdjustToDPI(170));
    SetStyle(csDropDownList);
    AddItemArray(['Item1', 'Mithril & Adamant', 'Item3', 'Item4']);
    SetItemIndex(2);
  end;

  Self.CreateVersionPanel(tab);

  Self.CreateAntibanManager();
  Self.CreateBankSettings();
  Self.CreateWaspLibSettings();
  Self.CreateAPISettings();

  inherited;
end;

var
  Config: TGiantsFoundryConfig;
{$ENDIF}

begin
  {$IFDEF SCRIPT_GUI}
  Config.Run();
  {$ENDIF}
  GiantsFoundry.Run(WLSettings.MaxActions(), WLSettings.MaxTime());
end.
